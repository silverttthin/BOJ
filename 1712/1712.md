이 문제는 반복문으로 하는 경우 21억번 이상의 연산이 필요하므로 반복문 풀이는 불가  

<br>  

```python
while(a+b*n >= c*n): n += 1
```

이 부분이 문제인데 반복문 연산 말고 다르게 처리해줘야함.  

**부등호 계산에서 가장 중요한 포인트**는 **등호가 있던 없던 두 항이 같은 경우**이다.  

```n = a / (c-b)``` 잠만 일캐 보니 정신사나움;; 정리 이전의 식으로 되돌아가보자.  

```a + b*n = c*n```  
총 지출과 총 수익이 같아지는 지점의 n을 나타내는 방정식이다.  
만약 정확히 두 값이 같다면 n은 정수일테고 다르다면 n은 실수형일 것이다.  

<br>  

우리가 관심있어하는 손익분기점은 위처럼 지출 == 수익이 **아니라** 지출 < 수익인 지점이다.  
그러면 딱 두 비용이 같게 되는 n에 + 1만큼 하면 그 시점부터는 수익이 지출보다 앞서는 포인트일 것이다.  

근데 n이 예를 들어 8.2회가 되면 어쩌지란 생각이 들었다. 그런데 좀  생각해보니 간단히 처리됐다.  

위의 글처럼 두값이 같다면 n은 정수이므로 +1을 하면 손익분기점의 n임에 의심의 여지가 없다. n이 8.2같은 실수라 하더라도 n=8인 지점은 지출>수익, n=9인 지점은 지출<수익 임에는 변함없이 사실일 것이다.  
따라서 n을 정수화 시켜주고 (by //연산자) +1 하면 타입상관없이 올바른 값이 도출될 듯?

<br>  

따라서 오류 코드 부분을 다음처럼 수정하자.  
```python
print(a//(c-b) + 1)
```

정리 : 부등호 계산의 포인트는 두 항이 같은 지점인 경우이다.
